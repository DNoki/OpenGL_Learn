#pragma once

#include <iostream>
#include <map>
#include <memory>
#include <string>

#include "List.h"
#include "GameObject.h"
#include "ResourceObject.h"

namespace OpenGL_Learn
{
    using namespace std;

    class ScriptBehaviour;

    class Scene
    {
    public:
        // 场景名称
        string Name;

        // 此场景的根变换数量。
        inline unsigned int GetRootCount() const { return (unsigned int)this->_hierarchy.size(); }
        inline List<unique_ptr<GameObject>>& GetAllGameObjects() { return this->_hierarchy; }
        List<GameObject*> GetAllRootGameObjects(bool isUnActiveInclude = false)
        {
            auto objs = List<GameObject*>();
            for (auto& obj : _hierarchy)
            {
                if (!isUnActiveInclude && !obj->GetActive()) continue;
                if (obj->IsRootObject())
                    objs.push_back(obj.get());
            }
            return objs;
        }
        inline map<string, List<unique_ptr<ResourceObject>>>& GetAllResourceObjects() { return this->_resourceObjects; }
        inline List<unique_ptr<ResourceObject>>& GetDestroyedObjects() { return _destroyedObjects; }


        // 添加资源
        template <typename T = ResourceObject>
        T* AddResourceObject(unique_ptr<T>&& obj)
        {
            return AddResourceObject(obj);
        }
        // 添加资源
        template <typename T = ResourceObject>
        T* AddResourceObject(unique_ptr<T>& obj)
        {
            auto key = typeid(T).name();
            if (_resourceObjects.count(key) == 0)
                _resourceObjects.insert(pair<string, List<unique_ptr<ResourceObject>>>(key, List<unique_ptr<ResourceObject>>()));
            auto result = obj.get();
            _resourceObjects[key].push_back(move(obj));
            return result;
        }
        // 寻找指定名称资源
        template <typename T = ResourceObject>
        T* FindResourceObject(const string& name)
        {
            auto key = typeid(T).name();
            if (_resourceObjects.count(key) == 0)
            {
                cout << "WARNING:: " << "资源总表中不存在 " << key << " 类型。" << endl;
                return nullptr;
            }

            for (auto& item : _resourceObjects[key])
            {
                if (item->Name == name)
                    return dynamic_cast<T*>(item.get());
            }
            return nullptr;
        }

        // 添加游戏对象
        GameObject& AddGameObject(unique_ptr<GameObject>&& gameObj);
        // 添加游戏对象
        GameObject& AddGameObject(unique_ptr<GameObject>& gameObj);
        // 查找并返回场景内找到的第一个已激活对象(仅检索根对象)
        GameObject* FindGameObject(const string& name) const;

        // 查找并返回场景内找到的第一个已激活组件
        template <typename T = Component>
        T* FindComponent(bool isUnActiveInclude = false) const
        {
            // 遍历所有对象，查找并返回第一个找到的对象
            for (auto& obj : _hierarchy)
            {
                if (!isUnActiveInclude && !obj->GetActive()) continue;

                auto component = obj->GetComponent<T>();
                if (component)
                    return component;
            }
            return nullptr;
        }
        // 获取场景内所有指定组件
        // @isUnActiveInclude 是否包括未激活对象
        template <typename T = Component>
        List<T*> FindComponents(bool isUnActiveInclude = false)
        {
            auto components = List<T*>();
            for (auto& obj : _hierarchy)
            {
                if (!isUnActiveInclude && !obj->GetActive()) continue;

                for (auto& component : obj->GetAllComponents())
                {
                    auto tryGetBehaviour = dynamic_cast<T*>(component.get());
                    if (tryGetBehaviour) components.push_back(tryGetBehaviour);
                }
            }
            return components;
        }


        // 初始化场景
        inline void Initialize()
        {
            ImportResource();
            BindMainObject();
        }
        void ExcuteUpdate();

        Scene(const string& name) :Name(name), _hierarchy(), _resourceObjects() {}

    protected:

        // 层导入
        virtual void ImportResource() = 0;

    private:
        // 游戏对象列表
        List<unique_ptr<GameObject>> _hierarchy;
        // 资源总表
        map<string, List<unique_ptr<ResourceObject>>> _resourceObjects;
        List<unique_ptr<ResourceObject>> _destroyedObjects;

        // 设定全局主要对象
        void BindMainObject();
    };
}